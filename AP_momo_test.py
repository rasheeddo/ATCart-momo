import numpy as np
from numpy import pi
import socket
import struct
import pickle
import time
import os
import json
os.environ["MAVLINK20"] = "2"
from apscheduler.schedulers.background import BackgroundScheduler
from dronekit import connect, VehicleMode
from pymavlink import mavutil
import subprocess
import argparse
import threading

############################### Arguments parser #############################################

parser = argparse.ArgumentParser(description='CUBE pilot and momo')
parser.add_argument('--port',
					help="This is a second port generated by 01_socat.sh")
parser.add_argument('--sim',
					help="This is for simulate in sitl")
# parser.add_argument('--baudrate', type=float,
#                     help="Vehicle connection baudrate. If not specified, a default value will be used.")
# parser.add_argument('--obstacle_distance_msg_hz', type=float,
#                     help="Update frequency for OBSTACLE_DISTANCE message. If not specified, a default value will be used.")
# parser.add_argument('--debug_enable',type=float, help="Enable debugging information")
args = parser.parse_args()
port = args.port
sim = args.sim
# FCU connection variables

if port is None:
	print("Error: please specify second port of socat generated")
	quit()

################################################################################################
vehicle = None
is_vehicle_connected = False
steering_ch = '1'
throttle_ch = '2'

global rover_status
global current_mode

cur_lat = 0.0
cur_lon = 0.0
cur_yaw = 0.0
gps_status = 0

rover_status = {"lat" : cur_lat, "lng" : cur_lon, "yaw" : cur_yaw, "gps" : gps_status}
out_file_path = "/home/nvidia/ATCart-momo/rover_status.txt"

def vehicle_connect():
	global vehicle, is_vehicle_connected, steering_ch, throttle_ch

	if vehicle == None:
		try:
			if sim is not None:
				if sim.startswith('sitl'):
					print("Connecting to Ardupilot on SITL...")
					vehicle = connect('udp:127.0.0.1:14551', wait_ready=True)
					steering_ch = '1'
					throttle_ch = '3'
				else:
					print('please enter --sim sitl for SITL simulator')
					quit()
			else:
				print("Connecting to Ardupilot....")
				vehicle = connect('/dev/usb_uart', wait_ready=True, baud=921600)
				steering_ch = '1'
				throttle_ch = '2'
		except KeyboardInterrupt:
			quit()
		except Exception as e:
			print(e)
			print('Check if there is /dev/usb_uart existed...')
			quit()
		

	if vehicle == None:
		is_vehicle_connected = False
		return False
	else:
		is_vehicle_connected = True
		return True

def turn(deg):
	if is_vehicle_connected == True:
		msg = vehicle.message_factory.set_position_target_local_ned_encode(
			0,       # time_boot_ms (not used)
			0, 0,    # target system, target component
			mavutil.mavlink.MAV_FRAME_BODY_NED, # frame
			0b0000101111111111, # type_mask (only speeds enabled)
			0, 0, 0, # x, y, z positions (not used)
			0, 0, 0, # x, y, z velocity in m/s
			0, 0, 0, # x, y, z acceleration (not supported yet, ignored in GCS_Mavlink)
			deg*pi/180.0, 0)    # yaw, yaw_rate (not supported yet, ignored in GCS_Mavlink)

		vehicle.send_mavlink(msg)
		# vehicle.flush()
	else:
		print("INFO: Vehicle not connected.")

def goForward(meter):
	if is_vehicle_connected == True:
		msg = vehicle.message_factory.set_position_target_local_ned_encode(
			0,       # time_boot_ms (not used)
			0, 0,    # target system, target component
			mavutil.mavlink.MAV_FRAME_BODY_NED, # frame
			0b0000111111111000, # type_mask (only speeds enabled)
			meter, 0, 0, # x, y, z positions (not used)
			0, 0, 0, # x, y, z velocity in m/s
			0, 0, 0, # x, y, z acceleration (not supported yet, ignored in GCS_Mavlink)
			0, 0)    # yaw, yaw_rate (not supported yet, ignored in GCS_Mavlink)
			
		vehicle.send_mavlink(msg)
		# vehicle.flush()
	else:
		print("INFO: Vehicle not connected.")

def goLeft(meter):
	if is_vehicle_connected == True:
		msg = vehicle.message_factory.set_position_target_local_ned_encode(
			0,       # time_boot_ms (not used)
			0, 0,    # target system, target component
			mavutil.mavlink.MAV_FRAME_BODY_NED, # frame
			0b0000111111111000, # type_mask (only speeds enabled)
			0, -meter, 0, # x, y, z positions (not used)
			0, 0, 0, # x, y, z velocity in m/s
			0, 0, 0, # x, y, z acceleration (not supported yet, ignored in GCS_Mavlink)
			0, 0)    # yaw, yaw_rate (not supported yet, ignored in GCS_Mavlink)
			
		vehicle.send_mavlink(msg)
		# vehicle.flush()
	else:
		print("INFO: Vehicle not connected.")

def goRight(meter):
	if is_vehicle_connected == True:
		msg = vehicle.message_factory.set_position_target_local_ned_encode(
			0,       # time_boot_ms (not used)
			0, 0,    # target system, target component
			mavutil.mavlink.MAV_FRAME_BODY_NED, # frame
			0b0000111111111000, # type_mask (only speeds enabled)
			0, meter, 0, # x, y, z positions (not used)
			0, 0, 0, # x, y, z velocity in m/s
			0, 0, 0, # x, y, z acceleration (not supported yet, ignored in GCS_Mavlink)
			0, 0)    # yaw, yaw_rate (not supported yet, ignored in GCS_Mavlink)
			
		vehicle.send_mavlink(msg)
		# vehicle.flush()
	else:
		print("INFO: Vehicle not connected.")


def read_socat(term):
	read = term.readline().decode()
	return read

# Callback to print the location in global frame
def location_callback(self, attr_name, value):
	# global cur_lat, cur_lon
	cur_lat = value.global_frame.lat
	cur_lon = value.global_frame.lon
	# print("cur_lat: %.7f  cur_lon: %.7f" %(cur_lat, cur_lon))
	rover_status['lat'] = cur_lat
	rover_status['lng'] = cur_lon
	
	# print(value.global_frame)

def attitude_callback(self, attr_name, value):
	# global cur_yaw
	cur_yaw = value.yaw
	# print("cur_yaw: %.6f" %cur_yaw)
	rover_status['yaw'] = cur_yaw
	## range is -pi to pi, 0 is north

def gps_callback(self, attr_name, value):
	# global gps_status
	gps_status = value.fix_type
	# print("gps_status: %d" %gps_status)
	rover_status['gps'] = gps_status
	# 3 = 3DFix
	# 4 = 3DGPS
	# 5 = rtkFloat
	# 6 = rtkFixed
	## range is -pi to pi, 0 is north

def change_flight_mode(_mode):

	global current_mode

	if current_mode != _mode:
		vehicle.mode = _mode
	current_mode = _mode


def gps_publish_worker(_out_file_path, lock, _port):

	global rover_status

	print("Started gps publisher thread")
	while True:

		file = open(_out_file_path, "w+")
		lock.acquire()
		json_data = json.dumps(rover_status)
		file.write(json_data)
		cmd1 = 'echo $(cat rover_status.txt) > {:s}'.format(_port)
		subprocess.run(cmd1, shell=True, check=True)
		# print("send rover status from thread")
		lock.release()
		time.sleep(0.1)



print("INFO: Connecting to vehicle.")
while (not vehicle_connect()):
	pass
print("INFO: Vehicle connected.")


vehicle.mode = "HOLD"
current_mode = "HOLD"
vehicle.armed= False

#BUTTONS:
# 0 A   		AUTO
# 1 B   		HOLD
# 2 X   		MANUAL
# 3 Y   		ARMDISARM
# 4 LB  		left 45
# 5 RB  		right 45 
# 6 LT  		left 90
# 7 RT  		right 90
# 16 Logicool   turn 180

#AXES
# Axis1 left stick up down
# Axis2 right stick left right

vehicle.add_attribute_listener('location', location_callback)
vehicle.add_attribute_listener('attitude', attitude_callback)
vehicle.add_attribute_listener('gps_0', gps_callback)

PORT = port

prev_arm_state = 0
prev_mode = 'NONE'

## Have to use another thread to publish rover status data, otherwise it cannot push back to browser
lock = threading.Lock()
gpsPublishThread = threading.Thread(target=gps_publish_worker, args=(out_file_path,lock,PORT), daemon=True)
gpsPublishThread.start()

####  This is a data packet that we will get from browser (as one single json)####
## { "ID" : "Logicool Gamepad F310 (STANDARD GAMEPAD Vendor: 046d Product: c21d)", 
## "TIMESTAMP" : 203376.22, "INDEX" : 0, "MAPPING" : "standard", 
## "AXES" : { "#00" : 0, "#01" : 0, "#02" : 0, "#03" : 0 }, 
## "BUTTONS" : { "#00" : 0, "#01" : 0, "#02" : 0, "#03" : 0, "#04" : 0, "#05" : 0, "#06" : 0, "#07" : 0, "#08" : 0, "#09" : 0, "#10" : 0, "#11" : 0, "#12" : 0, "#13" : 0, "#14" : 0, "#15" : 0, "#16" : 0 }, 
## "TOTAL_AXES" : 4, "TOTAL_BUTTONS" : 17, 
## "MODE": "HOLD", "TURN_DIR" : "NONE", "FORWARD" : 0, "LEFT" : 0, "RIGHT" : 0, "ARMED" : 0}


while True:

	with open(PORT, "rb", buffering=0) as term:
	
		try:
			str_buffer = read_socat(term)
			# print(str_buffer)
			dec = json.loads(str_buffer)

			#### Gamepad is plugged ####
			if len(str_buffer) > 400:
				### Mode / Armed ###
				if dec["BUTTONS"]["#02"] == 1 or (dec["MODE"] != prev_mode and dec["MODE"] == "MANUAL"):
					change_flight_mode("MANUAL")
					print("MANUAL")

				elif dec["BUTTONS"]["#01"] == 1 or (dec["MODE"] != prev_mode and dec["MODE"] == "HOLD"):
					change_flight_mode("HOLD")
					print("HOLD")

				elif dec["BUTTONS"]["#00"] == 1 or (dec["MODE"] != prev_mode and dec["MODE"] == "AUTO"):
					change_flight_mode("AUTO")
					print("AUTO")

				elif dec["BUTTONS"]["#03"] == 1 or int(dec['ARMED']) != prev_arm_state:
					if vehicle.armed == True:
						vehicle.armed= False
					else:
						vehicle.armed = True
					print("ARMDISARM")	

				### Direction Control ###
				if dec["BUTTONS"]["#04"] == 1 or dec["TURN_DIR"] == "TURNLEFT45":
					change_flight_mode("GUIDED")
					turn(-45)
					print("TURNLEFT45")

				elif dec["BUTTONS"]["#06"] == 1 or dec["TURN_DIR"] == "TURNLEFT90":
					change_flight_mode("GUIDED")
					turn(-90)
					print("TURNLEFT90")

				elif dec["BUTTONS"]["#05"] == 1 or dec["TURN_DIR"] == "TURNRIGHT45":
					change_flight_mode("GUIDED")
					turn(45)
					print("TURNRIGHT45")

				elif dec["BUTTONS"]["#07"] == 1 or dec["TURN_DIR"] == "TURNRIGHT90":
					change_flight_mode("GUIDED")
					turn(90)
					print("TURNRIGHT90")

				elif dec["BUTTONS"]["#16"] == 1 or dec["TURN_DIR"] == "TURN180":
					change_flight_mode("GUIDED")
					turn(180)	
					print("TURN180")

				elif dec["FORWARD"] != 0:
					change_flight_mode("GUIDED")
					goForward(int(dec["FORWARD"]))	
					print("GOFORWARD")

				elif dec["LEFT"] != 0:
					change_flight_mode("GUIDED")
					goLeft(int(dec["LEFT"]))	
					print("GOLEFT")

				elif dec["RIGHT"] != 0:
					change_flight_mode("GUIDED")
					goRight(int(dec["RIGHT"]))	
					print("GORIGHT")


				if current_mode == "MANUAL":
					STR_val = dec["AXES"]["#02"]
					THR_val = (-1)*dec["AXES"]["#01"]

					steering_pwm = int(round(STR_val*100 + 1500))
					throttle_pwm = int(round(THR_val*200 + 1500))
					vehicle.channels.overrides[steering_ch] = steering_pwm
					vehicle.channels.overrides[throttle_ch] = throttle_pwm
				else:
					vehicle.channels.overrides[steering_ch] = 1500
					vehicle.channels.overrides[throttle_ch] = 1500

				prev_mode = dec["MODE"]
				prev_arm_state = dec['ARMED']
			
			#### Without gamepad / only buttons on browser ####
			else:

				if (dec["MODE"] == "MANUAL"):
					change_flight_mode("MANUAL")
					print("WITHOUT_GAMEPAD : MANUAL")

				elif (dec["MODE"] == "AUTO"):
					change_flight_mode("AUTO")
					print("WITHOUT_GAMEPAD : AUTO")

				elif (dec["MODE"] == "HOLD"):
					change_flight_mode("HOLD")
					print("WITHOUT_GAMEPAD : HOLD")



				if (int(dec['ARMED']) != prev_arm_state):
					if vehicle.armed == True:
						vehicle.armed= False
					else:
						vehicle.armed = True
					print("WITHOUT_GAMEPAD : ARMDISARM")

				prev_arm_state = dec['ARMED']



				if dec["TURN_DIR"] == "TURNLEFT45":
					change_flight_mode("GUIDED")
					turn(-45)
					print("WITHOUT_GAMEPAD : TURNLEFT45")

				elif dec["TURN_DIR"] == "TURNLEFT90":
					change_flight_mode("GUIDED")
					turn(-90)
					print("WITHOUT_GAMEPAD : TURNLEFT90")

				elif dec["TURN_DIR"] == "TURNRIGHT45":
					change_flight_mode("GUIDED")
					turn(45)
					print("WITHOUT_GAMEPAD : TURNRIGHT45")

				elif dec["TURN_DIR"] == "TURNRIGHT90":
					change_flight_mode("GUIDED")
					turn(90)
					print("WITHOUT_GAMEPAD : TURNRIGHT90")

				elif dec["TURN_DIR"] == "TURN180":
					change_flight_mode("GUIDED")
					turn(180)	
					print("WITHOUT_GAMEPAD : TURN180")


				elif dec["FORWARD"] != 0:
					change_flight_mode("GUIDED")
					goForward(int(dec["FORWARD"]))	
					print("GOFORWARD")

				elif dec["LEFT"] != 0:
					change_flight_mode("GUIDED")
					goLeft(int(dec["LEFT"]))	
					print("GOLEFT")

				elif dec["RIGHT"] != 0:
					change_flight_mode("GUIDED")
					goRight(int(dec["RIGHT"]))	
					print("GORIGHT")

		except KeyboardInterrupt:
			quit()
		except Exception as e:
			print(e)
			print("Failed to parse")
			pass
